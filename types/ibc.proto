syntax = "proto3";

package types;

import "simple.proto";

// IBCKey represents the meaning of a key in the
// IBC merkle tree, it can easily be de/serialized
// with protobuf to provide context for the value.
//
// count is stored as fixed64, always 8 bytes, so
// integers are in lexographic order (eg. if B and A
// are identical, except B.count > A.count, then a
// byte-compare of serialized(B) > serialized(A)
message IBCKey {
    // chain_id is which chain this queue/header is
    // associated with
    string chain_id = 1;
    enum Content {
        HEADER = 0;
        INPUT = 1;
        OUTPUT = 2;
    }
    Content content = 2;
    // count is the packet number for input/output, or
    // the block height for the header
    fixed64 count = 3;
}

// IBCPacket sends a merkle proof along with routing
// information. Depending on the key/value sent as part of
// the proof (proof.data.path.node.{key,value}), this packet
// can be interpretted as a send packet or a receipt.
//
// src_chain and src_height are used to identify the sender
// and look up the header with which to verify this packet.
// dest_chain is used for routing when the packet traverses
// multiple chains, and can be left blank when sending
// directly to the destination chain.
message IBCPacket {
    string dest_chain = 1;
    string src_chain = 2;
    uint64 src_height = 3;
    MultiStoreProof proof = 4;
}
