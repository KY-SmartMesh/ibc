// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ibc.proto

/*
Package types is a generated protocol buffer package.

It is generated from these files:
	ibc.proto
	merkle.proto
	simple.proto

It has these top-level messages:
	IBCKey
	IBCPacket
	LeafNode
	ProofInnerNode
	PathWithNode
	KeyExistsProof
	KeyAbsentProof
	SubStore
	SimpleStep
	StoreProof
	MultiStoreProof
*/
package types

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type IBCKey_Content int32

const (
	IBCKey_HEADER IBCKey_Content = 0
	IBCKey_INPUT  IBCKey_Content = 1
	IBCKey_OUTPUT IBCKey_Content = 2
)

var IBCKey_Content_name = map[int32]string{
	0: "HEADER",
	1: "INPUT",
	2: "OUTPUT",
}
var IBCKey_Content_value = map[string]int32{
	"HEADER": 0,
	"INPUT":  1,
	"OUTPUT": 2,
}

func (x IBCKey_Content) String() string {
	return proto.EnumName(IBCKey_Content_name, int32(x))
}
func (IBCKey_Content) EnumDescriptor() ([]byte, []int) { return fileDescriptorIbc, []int{0, 0} }

// IBCKey represents the meaning of a key in the
// IBC merkle tree, it can easily be de/serialized
// with protobuf to provide context for the value.
//
// count is stored as fixed64, always 8 bytes, so
// integers are in lexographic order (eg. if B and A
// are identical, except B.count > A.count, then a
// byte-compare of serialized(B) > serialized(A)
type IBCKey struct {
	// chain_id is which chain this queue/header is
	// associated with
	ChainId string         `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	Content IBCKey_Content `protobuf:"varint,2,opt,name=content,proto3,enum=types.IBCKey_Content" json:"content,omitempty"`
	// count is the packet number for input/output, or
	// the block height for the header
	Count uint64 `protobuf:"fixed64,3,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *IBCKey) Reset()                    { *m = IBCKey{} }
func (m *IBCKey) String() string            { return proto.CompactTextString(m) }
func (*IBCKey) ProtoMessage()               {}
func (*IBCKey) Descriptor() ([]byte, []int) { return fileDescriptorIbc, []int{0} }

func (m *IBCKey) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *IBCKey) GetContent() IBCKey_Content {
	if m != nil {
		return m.Content
	}
	return IBCKey_HEADER
}

func (m *IBCKey) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

// IBCPacket sends a merkle proof along with routing
// information. Depending on the key/value sent as part of
// the proof (proof.data.path.node.{key,value}), this packet
// can be interpretted as a send packet or a receipt.
//
// src_chain and src_height are used to identify the sender
// and look up the header with which to verify this packet.
// dest_chain is used for routing when the packet traverses
// multiple chains, and can be left blank when sending
// directly to the destination chain.
type IBCPacket struct {
	DestChain string           `protobuf:"bytes,1,opt,name=dest_chain,json=destChain,proto3" json:"dest_chain,omitempty"`
	SrcChain  string           `protobuf:"bytes,2,opt,name=src_chain,json=srcChain,proto3" json:"src_chain,omitempty"`
	SrcHeight uint64           `protobuf:"varint,3,opt,name=src_height,json=srcHeight,proto3" json:"src_height,omitempty"`
	Proof     *MultiStoreProof `protobuf:"bytes,4,opt,name=proof" json:"proof,omitempty"`
}

func (m *IBCPacket) Reset()                    { *m = IBCPacket{} }
func (m *IBCPacket) String() string            { return proto.CompactTextString(m) }
func (*IBCPacket) ProtoMessage()               {}
func (*IBCPacket) Descriptor() ([]byte, []int) { return fileDescriptorIbc, []int{1} }

func (m *IBCPacket) GetDestChain() string {
	if m != nil {
		return m.DestChain
	}
	return ""
}

func (m *IBCPacket) GetSrcChain() string {
	if m != nil {
		return m.SrcChain
	}
	return ""
}

func (m *IBCPacket) GetSrcHeight() uint64 {
	if m != nil {
		return m.SrcHeight
	}
	return 0
}

func (m *IBCPacket) GetProof() *MultiStoreProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func init() {
	proto.RegisterType((*IBCKey)(nil), "types.IBCKey")
	proto.RegisterType((*IBCPacket)(nil), "types.IBCPacket")
	proto.RegisterEnum("types.IBCKey_Content", IBCKey_Content_name, IBCKey_Content_value)
}

func init() { proto.RegisterFile("ibc.proto", fileDescriptorIbc) }

var fileDescriptorIbc = []byte{
	// 272 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x34, 0x90, 0x41, 0x4b, 0xc3, 0x30,
	0x18, 0x86, 0xcd, 0x5c, 0xdb, 0xe5, 0x53, 0x64, 0x04, 0x95, 0xaa, 0x0c, 0x4a, 0x4f, 0x3d, 0x8c,
	0x0a, 0xf3, 0x17, 0xb8, 0x3a, 0x58, 0x11, 0xb5, 0xc4, 0xed, 0x3c, 0xb6, 0x34, 0xda, 0xe0, 0x6c,
	0x4a, 0x92, 0x1d, 0xf6, 0x3f, 0x3c, 0xf8, 0x73, 0x25, 0x49, 0xbd, 0xe5, 0x7b, 0x9e, 0x37, 0xe1,
	0xcd, 0x07, 0x58, 0xec, 0x58, 0xde, 0x29, 0x69, 0x24, 0x09, 0xcc, 0xb1, 0xe3, 0xfa, 0xf6, 0x5c,
	0x8b, 0xef, 0x6e, 0xcf, 0x3d, 0x4c, 0x7f, 0x11, 0x84, 0xe5, 0xbc, 0x78, 0xe6, 0x47, 0x72, 0x03,
	0x23, 0xd6, 0x6c, 0x45, 0xbb, 0x11, 0x75, 0x8c, 0x12, 0x94, 0x61, 0x1a, 0xb9, 0xb9, 0xac, 0xc9,
	0x3d, 0x44, 0x4c, 0xb6, 0x86, 0xb7, 0x26, 0x1e, 0x24, 0x28, 0xbb, 0x98, 0x5d, 0xe5, 0xee, 0xb1,
	0xdc, 0x5f, 0xcd, 0x0b, 0x2f, 0xe9, 0x7f, 0x8a, 0x5c, 0x42, 0xc0, 0xe4, 0xa1, 0x35, 0xf1, 0x69,
	0x82, 0xb2, 0x90, 0xfa, 0x21, 0x9d, 0x42, 0xd4, 0x27, 0x09, 0x40, 0xb8, 0x5c, 0x3c, 0x3e, 0x2d,
	0xe8, 0xf8, 0x84, 0x60, 0x08, 0xca, 0xd7, 0x6a, 0xbd, 0x1a, 0x23, 0x8b, 0xdf, 0xd6, 0x2b, 0x7b,
	0x1e, 0xa4, 0x3f, 0x08, 0x70, 0x39, 0x2f, 0xaa, 0x2d, 0xfb, 0xe2, 0x86, 0x4c, 0x00, 0x6a, 0xae,
	0xcd, 0xc6, 0x55, 0xea, 0xfb, 0x61, 0x4b, 0x0a, 0x0b, 0xc8, 0x1d, 0x60, 0xad, 0x58, 0x6f, 0x07,
	0xce, 0x8e, 0xb4, 0x62, 0x5e, 0x4e, 0x00, 0xac, 0x6c, 0xb8, 0xf8, 0x6c, 0x7c, 0xa5, 0x21, 0xb5,
	0xf1, 0xa5, 0x03, 0x64, 0x0a, 0x41, 0xa7, 0xa4, 0xfc, 0x88, 0x87, 0x09, 0xca, 0xce, 0x66, 0xd7,
	0xfd, 0xdf, 0x5e, 0x0e, 0x7b, 0x23, 0xde, 0x8d, 0x54, 0xbc, 0xb2, 0x96, 0xfa, 0xd0, 0x2e, 0x74,
	0x8b, 0x7b, 0xf8, 0x0b, 0x00, 0x00, 0xff, 0xff, 0xdc, 0xd4, 0x1a, 0x81, 0x5a, 0x01, 0x00, 0x00,
}
