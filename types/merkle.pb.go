// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: merkle.proto

package types

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// LeafNode contains the key/value pair to prove
type LeafNode struct {
	Key     []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value   []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Version uint64 `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *LeafNode) Reset()                    { *m = LeafNode{} }
func (m *LeafNode) String() string            { return proto.CompactTextString(m) }
func (*LeafNode) ProtoMessage()               {}
func (*LeafNode) Descriptor() ([]byte, []int) { return fileDescriptorMerkle, []int{0} }

func (m *LeafNode) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *LeafNode) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *LeafNode) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

// ProofInnerNode contains a step on the path from leaf to root
//
// Only one of left/right will be defined (the path not taken),
// the other one will be empty and should be filled with the
// value of the
type ProofInnerNode struct {
	Height uint32 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	Size_  uint64 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	Left   []byte `protobuf:"bytes,3,opt,name=left,proto3" json:"left,omitempty"`
	Right  []byte `protobuf:"bytes,4,opt,name=right,proto3" json:"right,omitempty"`
}

func (m *ProofInnerNode) Reset()                    { *m = ProofInnerNode{} }
func (m *ProofInnerNode) String() string            { return proto.CompactTextString(m) }
func (*ProofInnerNode) ProtoMessage()               {}
func (*ProofInnerNode) Descriptor() ([]byte, []int) { return fileDescriptorMerkle, []int{1} }

func (m *ProofInnerNode) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *ProofInnerNode) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *ProofInnerNode) GetLeft() []byte {
	if m != nil {
		return m.Left
	}
	return nil
}

func (m *ProofInnerNode) GetRight() []byte {
	if m != nil {
		return m.Right
	}
	return nil
}

// PathWithNode is the entire set of proofs from leaf data to
// root hash, but not including the root hash, as we may want
// to path multiple paths together for eg. key missing or range
// proofs.
type PathWithNode struct {
	Path []*ProofInnerNode `protobuf:"bytes,1,rep,name=path" json:"path,omitempty"`
	Node *LeafNode         `protobuf:"bytes,2,opt,name=node" json:"node,omitempty"`
}

func (m *PathWithNode) Reset()                    { *m = PathWithNode{} }
func (m *PathWithNode) String() string            { return proto.CompactTextString(m) }
func (*PathWithNode) ProtoMessage()               {}
func (*PathWithNode) Descriptor() ([]byte, []int) { return fileDescriptorMerkle, []int{2} }

func (m *PathWithNode) GetPath() []*ProofInnerNode {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *PathWithNode) GetNode() *LeafNode {
	if m != nil {
		return m.Node
	}
	return nil
}

// KeyExistsProof combines the proof of a given leaf node along
// with the root hash it should match. This must be calculated
// to verify, but the root hash first can be used to locate the
// needed header before running the proof verification.
type KeyExistsProof struct {
	Root []byte        `protobuf:"bytes,1,opt,name=root,proto3" json:"root,omitempty"`
	Path *PathWithNode `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
}

func (m *KeyExistsProof) Reset()                    { *m = KeyExistsProof{} }
func (m *KeyExistsProof) String() string            { return proto.CompactTextString(m) }
func (*KeyExistsProof) ProtoMessage()               {}
func (*KeyExistsProof) Descriptor() ([]byte, []int) { return fileDescriptorMerkle, []int{3} }

func (m *KeyExistsProof) GetRoot() []byte {
	if m != nil {
		return m.Root
	}
	return nil
}

func (m *KeyExistsProof) GetPath() *PathWithNode {
	if m != nil {
		return m.Path
	}
	return nil
}

// KeyAbsentProof represents a proof of the absence of a
// single key.
//
// left must be less than the missing key and right must be
// greater than the missing key.
// left and right must be adjacent paths (or leftmost/nil or
// nil/rightmost).
// this proves there is nothing between left and right, so key
// must not exist in the tree.
type KeyAbsentProof struct {
	Root  []byte        `protobuf:"bytes,1,opt,name=root,proto3" json:"root,omitempty"`
	Left  *PathWithNode `protobuf:"bytes,2,opt,name=left" json:"left,omitempty"`
	Right *PathWithNode `protobuf:"bytes,3,opt,name=right" json:"right,omitempty"`
}

func (m *KeyAbsentProof) Reset()                    { *m = KeyAbsentProof{} }
func (m *KeyAbsentProof) String() string            { return proto.CompactTextString(m) }
func (*KeyAbsentProof) ProtoMessage()               {}
func (*KeyAbsentProof) Descriptor() ([]byte, []int) { return fileDescriptorMerkle, []int{4} }

func (m *KeyAbsentProof) GetRoot() []byte {
	if m != nil {
		return m.Root
	}
	return nil
}

func (m *KeyAbsentProof) GetLeft() *PathWithNode {
	if m != nil {
		return m.Left
	}
	return nil
}

func (m *KeyAbsentProof) GetRight() *PathWithNode {
	if m != nil {
		return m.Right
	}
	return nil
}

func init() {
	proto.RegisterType((*LeafNode)(nil), "types.LeafNode")
	proto.RegisterType((*ProofInnerNode)(nil), "types.ProofInnerNode")
	proto.RegisterType((*PathWithNode)(nil), "types.PathWithNode")
	proto.RegisterType((*KeyExistsProof)(nil), "types.KeyExistsProof")
	proto.RegisterType((*KeyAbsentProof)(nil), "types.KeyAbsentProof")
}

func init() { proto.RegisterFile("merkle.proto", fileDescriptorMerkle) }

var fileDescriptorMerkle = []byte{
	// 290 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x91, 0xbf, 0x4f, 0xfb, 0x30,
	0x10, 0xc5, 0x95, 0x6f, 0xdc, 0x7e, 0xd1, 0x35, 0x14, 0x64, 0x7e, 0x28, 0x63, 0x14, 0x06, 0xd2,
	0x25, 0x43, 0xf9, 0x0b, 0x18, 0x18, 0x10, 0x05, 0x55, 0x5e, 0xd8, 0x90, 0x52, 0xf5, 0x42, 0xa2,
	0x06, 0x3b, 0xb2, 0x8f, 0xaa, 0xe1, 0xaf, 0x47, 0x39, 0x27, 0x12, 0x0c, 0x74, 0xbb, 0x73, 0x5e,
	0x3e, 0xef, 0xf9, 0x19, 0xa2, 0x0f, 0xb4, 0xbb, 0x06, 0xf3, 0xd6, 0x1a, 0x32, 0x72, 0x42, 0x5d,
	0x8b, 0x2e, 0x5d, 0xc1, 0xc9, 0x0a, 0x8b, 0xf2, 0xc5, 0x6c, 0x51, 0x9e, 0x43, 0xb8, 0xc3, 0x2e,
	0x0e, 0x92, 0x20, 0x8b, 0x54, 0x3f, 0xca, 0x4b, 0x98, 0xec, 0x8b, 0xe6, 0x13, 0xe3, 0x7f, 0x7c,
	0xe6, 0x17, 0x19, 0xc3, 0xff, 0x3d, 0x5a, 0x57, 0x1b, 0x1d, 0x87, 0x49, 0x90, 0x09, 0x35, 0xae,
	0x69, 0x09, 0xf3, 0xb5, 0x35, 0xa6, 0x7c, 0xd4, 0x1a, 0x2d, 0x33, 0xaf, 0x61, 0x5a, 0x61, 0xfd,
	0x5e, 0x11, 0x63, 0x4f, 0xd5, 0xb0, 0x49, 0x09, 0xc2, 0xd5, 0x5f, 0x1e, 0x2c, 0x14, 0xcf, 0xfd,
	0x59, 0x83, 0x25, 0x31, 0x34, 0x52, 0x3c, 0xf7, 0x09, 0x2c, 0xff, 0x2e, 0x7c, 0x02, 0x5e, 0xd2,
	0x37, 0x88, 0xd6, 0x05, 0x55, 0xaf, 0x35, 0x55, 0xec, 0xb2, 0x00, 0xd1, 0x16, 0x54, 0xc5, 0x41,
	0x12, 0x66, 0xb3, 0xe5, 0x55, 0xce, 0x77, 0xcb, 0x7f, 0x47, 0x51, 0x2c, 0x91, 0x37, 0x20, 0xb4,
	0xd9, 0x7a, 0xe3, 0xd9, 0xf2, 0x6c, 0x90, 0x8e, 0x1d, 0x28, 0xfe, 0x98, 0x3e, 0xc3, 0xfc, 0x09,
	0xbb, 0x87, 0x43, 0xed, 0xc8, 0x31, 0xa5, 0xcf, 0x66, 0x8d, 0xa1, 0xa1, 0x1c, 0x9e, 0xe5, 0xed,
	0xe0, 0xea, 0x51, 0x17, 0xa3, 0xeb, 0x8f, 0x60, 0xde, 0x33, 0x3d, 0x30, 0xee, 0x7e, 0xe3, 0x50,
	0xd3, 0x51, 0x1c, 0x5f, 0xff, 0x18, 0x8e, 0x3b, 0x59, 0x8c, 0x9d, 0x84, 0x7f, 0x2b, 0xbd, 0x62,
	0x33, 0xe5, 0xc7, 0xbe, 0xfb, 0x0e, 0x00, 0x00, 0xff, 0xff, 0xae, 0x11, 0xf4, 0x8d, 0xfc, 0x01,
	0x00, 0x00,
}
