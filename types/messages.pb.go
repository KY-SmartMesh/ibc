// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: messages.proto

package types

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// the message type, which determines what key/value mean
type IBCPacket_MsgType int32

const (
	IBCPacket_RECEIVE IBCPacket_MsgType = 0
	IBCPacket_RECEIPT IBCPacket_MsgType = 1
	IBCPacket_TIMEOUT IBCPacket_MsgType = 2
	IBCPacket_CLEANUP IBCPacket_MsgType = 3
)

var IBCPacket_MsgType_name = map[int32]string{
	0: "RECEIVE",
	1: "RECEIPT",
	2: "TIMEOUT",
	3: "CLEANUP",
}
var IBCPacket_MsgType_value = map[string]int32{
	"RECEIVE": 0,
	"RECEIPT": 1,
	"TIMEOUT": 2,
	"CLEANUP": 3,
}

func (x IBCPacket_MsgType) String() string {
	return proto.EnumName(IBCPacket_MsgType_name, int32(x))
}
func (IBCPacket_MsgType) EnumDescriptor() ([]byte, []int) { return fileDescriptorMessages, []int{1, 0} }

type MerkleProof struct {
}

func (m *MerkleProof) Reset()                    { *m = MerkleProof{} }
func (m *MerkleProof) String() string            { return proto.CompactTextString(m) }
func (*MerkleProof) ProtoMessage()               {}
func (*MerkleProof) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{0} }

// IBCPacket sends a proven key/value pair from an IBCQueue.
// Depending on the type of message, we require a certain type
// of key (MessageKey at a given height, or StateKey).
//
// Includes src_chain and src_height to look up the proper
// header to verify the merkle proof.
type IBCPacket struct {
	// chain id it is coming from
	SrcChain string `protobuf:"bytes,1,opt,name=src_chain,json=srcChain,proto3" json:"src_chain,omitempty"`
	// height for the header the proof belongs to
	SrcHeight uint64            `protobuf:"varint,2,opt,name=src_height,json=srcHeight,proto3" json:"src_height,omitempty"`
	MsgType   IBCPacket_MsgType `protobuf:"varint,3,opt,name=msgType,proto3,enum=types.IBCPacket_MsgType" json:"msgType,omitempty"`
	Key       []byte            `protobuf:"bytes,4,opt,name=key,proto3" json:"key,omitempty"`
	Value     []byte            `protobuf:"bytes,5,opt,name=value,proto3" json:"value,omitempty"`
	// the proof of the message
	Proof *MerkleProof `protobuf:"bytes,6,opt,name=proof" json:"proof,omitempty"`
}

func (m *IBCPacket) Reset()                    { *m = IBCPacket{} }
func (m *IBCPacket) String() string            { return proto.CompactTextString(m) }
func (*IBCPacket) ProtoMessage()               {}
func (*IBCPacket) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{1} }

func (m *IBCPacket) GetSrcChain() string {
	if m != nil {
		return m.SrcChain
	}
	return ""
}

func (m *IBCPacket) GetSrcHeight() uint64 {
	if m != nil {
		return m.SrcHeight
	}
	return 0
}

func (m *IBCPacket) GetMsgType() IBCPacket_MsgType {
	if m != nil {
		return m.MsgType
	}
	return IBCPacket_RECEIVE
}

func (m *IBCPacket) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *IBCPacket) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *IBCPacket) GetProof() *MerkleProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func init() {
	proto.RegisterType((*MerkleProof)(nil), "types.MerkleProof")
	proto.RegisterType((*IBCPacket)(nil), "types.IBCPacket")
	proto.RegisterEnum("types.IBCPacket_MsgType", IBCPacket_MsgType_name, IBCPacket_MsgType_value)
}

func init() { proto.RegisterFile("messages.proto", fileDescriptorMessages) }

var fileDescriptorMessages = []byte{
	// 256 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x4c, 0x90, 0x41, 0x4b, 0x84, 0x40,
	0x1c, 0xc5, 0x1b, 0x5d, 0xd7, 0xfc, 0x5b, 0x8b, 0x0c, 0x1d, 0x06, 0x22, 0x10, 0x4f, 0x73, 0xf2,
	0x60, 0xe7, 0x0e, 0x25, 0x03, 0x09, 0x59, 0x32, 0xb8, 0x5d, 0xc3, 0xe4, 0x9f, 0x2e, 0xee, 0xa6,
	0xcc, 0x58, 0xe0, 0x77, 0xe8, 0x43, 0xc7, 0xe8, 0xb6, 0x74, 0x9b, 0xdf, 0x7b, 0x8f, 0xf7, 0x66,
	0x06, 0x36, 0x07, 0xd4, 0xba, 0x6a, 0x50, 0xc7, 0x83, 0xea, 0xc7, 0x9e, 0x3a, 0xe3, 0x34, 0xa0,
	0x8e, 0x2e, 0xc1, 0xcf, 0x51, 0x75, 0x7b, 0x2c, 0x54, 0xdf, 0x7f, 0x44, 0x3f, 0x16, 0x78, 0xd9,
	0x43, 0x5a, 0x54, 0x75, 0x87, 0x23, 0xbd, 0x06, 0x4f, 0xab, 0xfa, 0xad, 0x6e, 0xab, 0xdd, 0x27,
	0x23, 0x21, 0xe1, 0x9e, 0x3c, 0xd7, 0xaa, 0x4e, 0x0d, 0xd3, 0x1b, 0x00, 0x63, 0xb6, 0xb8, 0x6b,
	0xda, 0x91, 0x59, 0x21, 0xe1, 0x2b, 0x69, 0xe2, 0x8f, 0xb3, 0x40, 0x13, 0x70, 0x0f, 0xba, 0x29,
	0xa7, 0x01, 0x99, 0x1d, 0x12, 0xbe, 0x49, 0x58, 0x3c, 0x2f, 0xc6, 0xa7, 0xfa, 0x38, 0x5f, 0x7c,
	0xf9, 0x17, 0xa4, 0x01, 0xd8, 0x1d, 0x4e, 0x6c, 0x15, 0x12, 0x7e, 0x21, 0xcd, 0x91, 0x5e, 0x81,
	0xf3, 0x5d, 0xed, 0xbf, 0x90, 0x39, 0xb3, 0xb6, 0x00, 0xe5, 0xe0, 0x0c, 0xe6, 0xba, 0x6c, 0x1d,
	0x12, 0xee, 0x27, 0xf4, 0xd8, 0xfc, 0xef, 0x21, 0x72, 0x09, 0x44, 0x77, 0xe0, 0x1e, 0x57, 0xa8,
	0x0f, 0xae, 0x14, 0xa9, 0xc8, 0x5e, 0x45, 0x70, 0x76, 0x82, 0xa2, 0x0c, 0x88, 0x81, 0x32, 0xcb,
	0xc5, 0xcb, 0xb6, 0x0c, 0x2c, 0x03, 0xe9, 0x93, 0xb8, 0x7f, 0xde, 0x16, 0x81, 0xfd, 0xbe, 0x9e,
	0xff, 0xea, 0xf6, 0x37, 0x00, 0x00, 0xff, 0xff, 0x2d, 0x7b, 0x51, 0xc7, 0x3d, 0x01, 0x00, 0x00,
}
